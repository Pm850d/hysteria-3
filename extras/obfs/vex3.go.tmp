package obfs

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/binary"
	"errors"
	"sync"
	"time"
)

const (
	vex3SeqLen  = 4
	vex3MacLen  = 16
	vex3MinLen  = vex3SeqLen + vex3MacLen
	vex3KeyLen  = 32
	vex3TimeWin = 2
)

var _ Obfuscator = (*Vex3Obfuscator)(nil)

var ErrVex3KeyTooShort = errors.New("Vex3 key must be at least 4 bytes")
var ErrVex3InvalidPacket = errors.New("Vex3 packet too short or invalid")


type Vex3ParamsCache struct {
	Params *Vex3Params
	Minute int64

type Vex3Obfuscator struct {
	Key            []byte
	Mu             sync.Mutex
	Seq            uint32
	LastMin        int64
	ParamsCache    *Vex3ParamsCache
	KeystreamCache []byte

func NewVex3Obfuscator(key []byte) (*Vex3Obfuscator, error) {
	if len(key) < 4 {
		return nil, ErrVex3KeyTooShort
	return &Vex3Obfuscator{
		Key:            key,
		Seq:            0,
		LastMin:        time.Now().Unix() / 60,
		ParamsCache:    nil,
		KeystreamCache: nil,

func (o *Vex3Obfuscator) Obfuscate(in, out []byte) int {
	o.Mu.Lock()
	nowMin := time.Now().Unix() / 60
	if nowMin != o.LastMin {
		o.LastMin = nowMin
		o.Seq = 0
	seq := int(o.Seq)
	o.Seq++
	o.Mu.Unlock()

	params := o.getCachedParams(nowMin, seq)
	if params == nil {
		return 0

	ksLen := max(1, len(in)*4+64)
	ks := o.getKeystream(params.SeedBytes, ksLen)

	plainLen := len(in)

	buf := bufferPool.Get().([]byte)
	if cap(buf) < plainLen {
		buf = make([]byte, plainLen)
		buf = buf[:plainLen]
	// не ставим defer Put(buf) — мы положим в пул тело ниже

	for i := 0; i < plainLen; i++ {
		v := in[i]
		for _, op := range params.Ops {
			v = applyOp(v, params, ks, i, op)
		buf[i] = v

	seqBytes := make([]byte, vex3SeqLen)
	binary.LittleEndian.PutUint32(seqBytes, uint32(seq))

	body := bufferPool.Get().([]byte)
	if cap(body) < vex3SeqLen+plainLen+vex3MacLen {
		body = make([]byte, 0, vex3SeqLen+plainLen+vex3MacLen)
		body = body[:0]

	body = append(body, seqBytes...)
	body = append(body, buf[:plainLen]...)

	tag := computeMacFast(body, o.Key, int(nowMin), seq)
	body = append(body, tag...)

	// вернём буферы в пул
	bufferPool.Put(buf)
	bufferPool.Put(body[:0]) // положим пустой слайс, чтобы пул не хранил большие длины неконтролируемо

	if len(out) < len(body) {
		return 0
	copy(out, body)
	return len(body)

func (o *Vex3Obfuscator) Deobfuscate(in, out []byte) int {
	if len(in) < vex3MinLen {
		return 0

	nowMin := time.Now().Unix() / 60

	for offset := 0; offset <= vex3TimeWin; offset++ {
		var tryMin int64
		if offset == 0 {
			tryMin = nowMin
			tryMin = nowMin - int64((offset+1)/2)
			tryMin = nowMin + int64(offset/2)

		decrypted, err := o.decryptBytesDynamic(in, int(tryMin))
		if err == nil {
			if len(out) < len(decrypted) {
				// вернуть буфер в пул перед выходом
				bufferPool.Put(decrypted[:0])
				return 0
			copy(out, decrypted)
			bufferPool.Put(decrypted[:0])
			return len(decrypted)

	return 0

func (o *Vex3Obfuscator) getCachedParams(minute int64, seq int) *Vex3Params {
	o.Mu.Lock()
	defer o.Mu.Unlock()

	if o.ParamsCache != nil && o.ParamsCache.Minute == minute {
		return o.ParamsCache.Params

	seedBytes := makeSeedBytesFast(o.Key, int(minute), seq)
	params := generateParams(seedBytes)

	o.ParamsCache = &Vex3ParamsCache{
		Params: params,
		Minute: minute,

	o.ParamsCache.Params.SeedBytes = seedBytes

	return params

func (o *Vex3Obfuscator) getKeystream(seedBytes []byte, nbytes int) []byte {
	o.Mu.Lock()
	defer o.Mu.Unlock()

	if o.KeystreamCache != nil && len(o.KeystreamCache) >= nbytes {
		return o.KeystreamCache[:nbytes]

	if cap(o.KeystreamCache) < nbytes {
		o.KeystreamCache = make([]byte, nbytes)
		o.KeystreamCache = o.KeystreamCache[:nbytes]

	keystreamFromSeedFast(seedBytes, o.KeystreamCache)
	return o.KeystreamCache

func (o *Vex3Obfuscator) decryptBytesDynamic(data []byte, minute int) ([]byte, error) {
	if len(data) < vex3MinLen {
		return nil, ErrVex3InvalidPacket

	seq := int(binary.LittleEndian.Uint32(data[:vex3SeqLen]))
	cipherBody := data[vex3SeqLen : len(data)-vex3MacLen]
	tag := data[len(data)-vex3MacLen:]

	body := data[:len(data)-vex3MacLen]
	expectedTag := computeMacFast(body, o.Key, minute, seq)
	if !hmac.Equal(expectedTag, tag) {
		return nil, ErrVex3InvalidPacket

	params := o.getCachedParams(int64(minute), seq)
	if params == nil {
		return nil, ErrVex3InvalidPacket

	ks := o.getKeystream(params.SeedBytes, max(1, len(cipherBody)*4+64))

	decrypted := bufferPool.Get().([]byte)
	if cap(decrypted) < len(cipherBody) {
		decrypted = make([]byte, len(cipherBody))
		decrypted = decrypted[:len(cipherBody)]

	for i := 0; i < len(cipherBody); i++ {
		v := cipherBody[i]
		for j := len(params.Ops) - 1; j >= 0; j-- {
			v = applyOpInv(v, params, ks, i, params.Ops[j])
		decrypted[i] = v

	return decrypted, nil

func makeSeedBytesFast(baseKey []byte, minute int, seq int) []byte {
	h := sha256.New()
	h.Write(baseKey)

	var buf [20]byte
	n := binary.PutVarint(buf[:], int64(minute))
	h.Write(buf[:n])
	n = binary.PutVarint(buf[:], int64(seq))
	h.Write(buf[:n])

	return h.Sum(nil)

func computeMacFast(body []byte, baseKey []byte, minute int, seq int) []byte {
	h := hmac.New(sha256.New, baseKey)

	var buf [20]byte
	n := binary.PutVarint(buf[:], int64(minute))
	h.Write(buf[:n])
	n = binary.PutVarint(buf[:], int64(seq))
	h.Write(buf[:n])
	h.Write(body)

	return h.Sum(nil)[:vex3MacLen]

type Vex3Params struct {
	Ops      []string
	Mask1    uint8
	Mul1     uint8
	Mul1Inv  uint8
	Add1     uint8
	Mask2    uint8
	Shift2   uint8
	Add2     uint8
	Mul3     uint8
	Mul3Inv  uint8
	Add3     uint8
	Mask4    uint8
	Shift5   uint8
	Add5     uint8
	Perm     [8]uint8
	SBox     [256]uint8
	InvSBox  [256]uint8
	SeedBytes []byte

func generateParams(seedBytes []byte) *Vex3Params {
	ks := make([]byte, 128)
	keystreamFromSeedFast(seedBytes, ks)

	// гарантируем нечётность и ненулевое значение (чтобы обратимый элемент по модулю 256 существовал)
	mul1 := uint8((ks[1] & 0xFE) | 1)
	mul3 := uint8((ks[6] & 0xFE) | 1)

	params := &Vex3Params{
		Mask1:   ks[0],
		Mul1:    uint8(mul1),
		Mul1Inv: modInverse(uint8(mul1), 256),
		Add1:    ks[2],
		Mask2:   ks[3],
		Shift2:  ks[4] & 7,
		Add2:    ks[5],
		Mul3:    uint8(mul3),
		Mul3Inv: modInverse(uint8(mul3), 256),
		Add3:    ks[7],
		Mask4:   ks[8],
		Shift5:  ks[9] & 7,
		Add5:    ks[10],

	gen := newXorShift128(seedBytes)
	for i := 7; i > 0; i-- {
		j := int(gen.Next() % uint64(i+1))
		perm[i], perm[j] = perm[j], perm[i]
	params.Perm = perm

	for i := 0; i < 256; i++ {
		sbox[i] = uint8(i)
	for i := 255; i > 0; i-- {
		j := int(gen.Next() % uint64(i+1))
		sbox[i], sbox[j] = sbox[j], sbox[i]
	params.SBox = sbox

	for i := 0; i < 256; i++ {
		params.InvSBox[sbox[i]] = uint8(i)

	for i := len(opPool) - 1; i > 0; i-- {
		j := int(gen.Next() % uint64(i+1))
		opPool[i], opPool[j] = opPool[j], opPool[i]
	length := int(ks[0]%5) + 5
	if length > len(opPool) {
		length = len(opPool)
	rotOffset := int(ks[1] % uint8(len(opPool)))
	ops := append(opPool[rotOffset:], opPool[:rotOffset]...)
	params.Ops = ops[:length]

	return params

func keystreamFromSeedFast(seedBytes []byte, out []byte) {
	gen := newXorShift128(seedBytes)
	for i := 0; i < len(out); i += 8 {
		v := gen.Next()
		for j := 0; j < 8 && i+j < len(out); j++ {
			out[i+j] = byte((v >> (j * 8)) & 0xFF)

type XorShift128 struct {
	a uint64
	b uint64

func newXorShift128(seedBytes []byte) *XorShift128 {
	padded := make([]byte, 16)
	copy(padded, seedBytes)
	return &XorShift128{
		a: binary.LittleEndian.Uint64(padded[:8]),
		b: binary.LittleEndian.Uint64(padded[8:16]),

func (x *XorShift128) Next() uint64 {
	mask := uint64(0xFFFFFFFFFFFFFFFF)
	x.a ^= (x.a << 23) & mask
	x.a ^= (x.a >> 17) & mask
	x.b ^= (x.b << 26) & mask
	x.b ^= (x.b >> 11) & mask
	v := (x.a + x.b) & mask
	x.a = (x.a ^ v) & mask
	x.b = (rotl64(v, 13) ^ x.b) & mask
	return v

func rotl64(x uint64, r uint64) uint64 {
	r &= 63
	return (x << r) | (x >> (64 - r))

func rotl8(b uint8, r uint8) uint8 {
	r &= 7
	return (b << r) | (b >> (8 - r))

func rotr8(b uint8, r uint8) uint8 {
	r &= 7
	return (b >> r) | (b << (8 - r))

func modInverse(a uint8, m int) uint8 {
	// расширенный алгоритм Евклида, без паники — если обратного нет, вернём 1 (безопасный заглуш)
	if a == 0 {
		return 1

	a32 := int32(a)
	m32 := int32(m)
	var t, newt int32 = 0, 1
	var r, newr int32 = m32, a32

	for newr != 0 {
		q := r / newr
		t, newt = newt, t-q*newt
		r, newr = newr, r-q*newr

	if r > 1 {
		return 1
	if t < 0 {
		t += m32
	return uint8(t)

func swapNibbles(b uint8) uint8 {
	return ((b << 4) & 0xF0) | ((b >> 4) & 0x0F)

func reverseBits(b uint8) uint8 {
	var r uint8 = 0
	for i := 0; i < 8; i++ {
		r = (r << 1) | ((b >> i) & 1)
	return r

func shuffleBits(b uint8, perm [8]uint8) uint8 {
	var res uint8 = 0
	for srcIdx := 0; srcIdx < 8; srcIdx++ {
		bit := (b >> srcIdx) & 1
		res |= (bit << perm[srcIdx])
	return res

func unshuffleBits(b uint8, perm [8]uint8) uint8 {
	for i, p := range perm {
		inv[p] = uint8(i)
	return shuffleBits(b, inv)

func applyOp(v uint8, params *Vex3Params, ks []byte, i int, op string) uint8 {
	switch op {
	case "xrot":
		k := ks[(i*2)%len(ks)]
		shift := ks[(i*2+1)%len(ks)] & 7
		return rotl8(v^k, shift)
	case "f1":
		t := (v ^ params.Mask1) & 0xFF
		t = (t*params.Mul1 + params.Add1) & 0xFF
		t = (t ^ uint8(i&0xFF)) & 0xFF
		return params.SBox[t]
	case "f2":
		t := (v + uint8((i*13)&0xFF)) & 0xFF
		t = t ^ params.Mask2
		return rotl8(t, params.Shift2)
	case "f3":
		return ((v * params.Mul3) & 0xFF) ^ ((params.Add3 + uint8(i)) & 0xFF)
	case "f4":
		return v ^ rotl8(params.Mask4, uint8(i&7))
	case "f5":
		t := rotl8(v, params.Shift5)
		return (t + params.Add5) & 0xFF
	case "swap_nibbles":
		return swapNibbles(v)
	case "reverse_bits":
		return reverseBits(v)
	case "shuffle_bits":
		return shuffleBits(v, params.Perm)
	return v

func applyOpInv(v uint8, params *Vex3Params, ks []byte, i int, op string) uint8 {
	switch op {
	case "xrot":
		k := ks[(i*2)%len(ks)]
		shift := ks[(i*2+1)%len(ks)] & 7
		return rotr8(v, shift) ^ k
	case "f1":
		t := params.InvSBox[v]
		t = ((t ^ uint8(i&0xFF)) - params.Add1) & 0xFF
		t = (t * params.Mul1Inv) & 0xFF
		return t ^ params.Mask1
	case "f2":
		t := rotr8(v, params.Shift2)
		t = t ^ params.Mask2
		return (t - uint8((i*13)&0xFF)) & 0xFF
	case "f3":
		t := v ^ ((params.Add3 + uint8(i)) & 0xFF)
		return (t * params.Mul3Inv) & 0xFF
	case "f4":
		return v ^ rotl8(params.Mask4, uint8(i&7))
	case "f5":
		t := (v - params.Add5) & 0xFF
		return rotr8(t, params.Shift5)
	case "swap_nibbles":
		return swapNibbles(v)
	case "reverse_bits":
		return reverseBits(v)
	case "shuffle_bits":
		return unshuffleBits(v, params.Perm)
	return v

func max(a, b int) int {
	if a > b {
		return a
	return b
